% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nmfbin.R
\name{nmfbin}
\alias{nmfbin}
\title{Logistic Non-negative Matrix Factorization}
\usage{
nmfbin(
  X,
  k,
  optimizer = "mur",
  init = "nndsvd",
  max_iter = 1000,
  tol = 1e-06,
  learning_rate = 0.001,
  verbose = FALSE,
  loss_fun = "logloss",
  loss_normalize = TRUE,
  epsilon = 1e-10
)
}
\arguments{
\item{X}{A binary matrix (m x n) to be factorized.}

\item{k}{The number of factors or components.}

\item{optimizer}{Type of updating algorithm. \code{update} for NMF multiplicative update rules or \code{gradient} for gradient descent.}

\item{init}{Method for initializing the factorization.}

\item{max_iter}{Maximum number of iterations for the gradient descent optimization.}

\item{tol}{Convergence tolerance. The optimization stops when the change in loss is less than this value.}

\item{learning_rate}{Learning rate (step size) for the gradient descent optimization.}

\item{verbose}{Print convergence if \code{TRUE}.}

\item{loss_fun}{Choice of loss function.}

\item{loss_normalize}{Normalize loss if \code{TRUE}.}

\item{epsilon}{Constant to avoid log(0).}
}
\value{
A list containing:
\itemize{
\item \code{W}: The basis matrix (m x k).
\item \code{H}: The coefficient matrix (k x n).
\item \code{c}: The global threshold.
}
}
\description{
This function performs Logistic Non-negative Matrix Factorization (NMF) on a binary matrix.
}
\examples{
\dontrun{
# Generate a binary matrix of size 100 x 50
set.seed(123)
m <- 100
n <- 50
X <- matrix(sample(c(0, 1), m * n, replace = TRUE), m, n)

# Set the number of factors
k <- 4

# Apply the function
result <- nmfbin(X, k)
}

}
